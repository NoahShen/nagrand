{"name":"Nagrand","tagline":"a lightweight groovy orm","body":"Nagrand\r\n==========\r\n\r\nNagrand is a lightweight groovy orm\r\n\r\n-------\r\n\r\n## How To Use\r\nMaven dependency\r\n```xml\r\n<dependency>\r\n    <groupId>io.github.noahshen</groupId>\r\n    <artifactId>nagrand</artifactId>\r\n    <version>0.0.1-SNAPSHOT</version>\r\n</dependency>\r\n```\r\n\r\nYou need to register classes through Nagrand on app start.\r\n\r\n```groovy\r\nNagrand nagrand = ...\r\nnagrand.register(Person)\r\n```\r\n\r\n## Basic Samples\r\n\r\n### Entity defination\r\n```groovy\r\n@Entity\r\nclass Person {\r\n    def name\r\n    int age\r\n}\r\n```\r\n\r\n### Create\r\n```groovy\r\ndef person = new Person(name: 'Spiderman', age: 30)\r\nperson.save()\r\n```\r\n### Update\r\n```groovy\r\ndef person = new Person(name: 'Spiderman', age: 30)\r\nperson.save()\r\n\r\nperson.name = 'Batman'\r\nperson.save()\r\n```\r\n\r\n### Delete\r\n```groovy\r\ndef person = new Person(name: 'Spiderman', age: 30)\r\n\r\n//...\r\n\r\nperson.delete()\r\n```\r\n\r\n### Query\r\n\r\n### Get entity by ID\r\n```groovy\r\nInteger id = 1\r\nPerson p = Person.get(id)\r\nif (!p) {\r\n   //... not found\r\n}\r\n```\r\n\r\n### Dynamic Finders\r\n\r\nDynamic finder looks like a static method invocation.\r\nThe method is auto-generated using code synthesis at runtime, based on the properties of a entity class. \r\n\r\n```groovy\r\nnew Person(name: 'Spiderman', age: 30).save()\r\nnew Person(name: 'Batman', age: 31).save()\r\nnew Person(name: 'Superman', age: 32).save()\r\nnew Person(name: 'Ironman', age: 32).save()\r\n\r\ndef persons = Person.findByAge(32)\r\nassert persons.size() == 2\r\nassert persons*.name == [\"Superman\", \"Ironman\"]\r\n\r\ndef batman = Person.findFirstByName(\"Batman\")\r\nassert batman.name == \"Batman\"\r\n```\r\n\r\nFind by multi properties\r\n```groovy\r\nList<Person> persons = Person.findByNameAndAge('Superman', 32)\r\nassert persons.size() == 1\r\nassert persons*.name == [\"Superman\"]\r\n```\r\nFind by more options\r\n```groovy\r\nList<Person> persons = Person.findByAge(32) {\r\n    order(\"name\", \"desc\")\r\n}\r\nassert persons.size() == 2\r\nassert persons[0].name == \"Superman\"\r\n```\r\n\r\n### Where Query\r\n\r\nThe where method is more flexible than dynamic finders\r\n\r\nby using the following methods:\r\n\r\n - `.find {}`\r\n - `.findWhere {}`\r\n - `.where {}`\r\n - `.findFirst {}`\r\n - `.findFirstWhere {}`\r\n\r\n\r\n```groovy\r\nnew Person(name: 'Spiderman', age: 30).save()\r\nnew Person(name: 'Batman', age: 31).save()\r\nnew Person(name: 'Superman', age: 32).save()\r\nnew Person(name: 'Ironman', age: 32).save()\r\n\r\nList<Person> persons = Person.find {\r\n    eq \"name\", \"Superman\"\r\n    eq \"age\", 32\r\n}\r\nassert persons.size() == 1\r\nassert persons*.name == [\"Superman\"]\r\n```\r\n\r\nMore condition:\r\n```groovy\r\ndef results = Account.find {\r\n    between(\"balance\", 500, 1000)\r\n    eq(\"bankName\", \"boc\")\r\n    or {\r\n        like(\"firstName\", \"Noah%\")\r\n        like(\"firstName\", \"Sara%\")\r\n    }\r\n    maxResults(10)\r\n    order(\"balance\", \"desc\")\r\n}\r\n```\r\n\r\n### Groovy-style query\r\nNagrand supports groovy-style query by providing an enhanced, compile-time checked query DSL for common queries\r\n\r\n```groovy\r\ndef person = Person.where {\r\n   firstName == \"Ironman\"\r\n}\r\n```\r\n\r\n```groovy\r\ndef person = Person.where {\r\n    (lastName != \"Shen\" && firstName != \"Noah\") || (firstName == \"Sara\" && age > 20)\r\n}\r\n```\r\n\r\nGroovy operator maps onto a where method. \r\nThe following table provides a map of Groovy operators to methods:\r\n\r\n| Operator   | where method | description  |\r\n| --------   | -----   | ----  |\r\n| ==         | eq      | Equal to   |\r\n| !=         | nq      | Not equal to   |\r\n| >          | gt      | Greater than  |\r\n| <          | lt      | Less than |\r\n| \\>=        | ge      | Greater than or equal to |\r\n| <=         | le      | Less than or equal to |\r\n| in         | inList  | Contained within the given list |\r\n\r\n\r\n### Events\r\n\r\n`.beforeInsert`\r\n\r\n`.afterInsert`\r\n\r\nCalled before/after first save\r\n```groovy\r\nclass Item {\r\n  void beforeInsert() {\r\n    ...\r\n  }\r\n  void afterInsert() {\r\n    ...\r\n  }\r\n}\r\n```\r\n\r\n`.beforeUpdate`\r\n\r\n`.afterUpdate`\r\n\r\nCalled before/after object update\r\n```groovy\r\nclass Item {\r\n  void beforeUpdate() {\r\n    ...\r\n  }\r\n  void afterUpdate() {\r\n    ...\r\n  }\r\n}\r\n```\r\n\r\n`.beforeDelete`\r\n\r\n`.afterDelete`\r\n\r\nCalled before/after object delete\r\n```groovy\r\nclass Item {\r\n  void beforeDelete() {\r\n    ...\r\n  }\r\n  void afterDelete() {\r\n    ...\r\n  }\r\n}\r\n```\r\n\r\n### Optimistic Locking and Version\r\nNagrand uses optimistic locking by a version property which is in turn mapped to a version column at the database.\r\n\r\n```groovy\r\nclass ClassWithVersion {\r\n    Integer id\r\n    String name\r\n    Integer version\r\n}\r\n```\r\n\r\n```groovy\r\ndef entity = new ClassWithVersion(name: 'Spiderman').save()\r\nassert entity.version == 1\r\n\r\nentity.name = \"Superman\"\r\nentity.save()\r\nassert entity.version == 2\r\n```\r\n\r\n### Automatic timestamping\r\n\r\nIf you define a dateCreated property, it will be set to the current date for you when you create new instances. Likewise, if you define a lastUpdated property it will be automatically be updated for you when you change the instances.\r\n\r\n```groovy\r\nclass ClassAutoTimestamp {\r\n    Integer id\r\n    String name\r\n    Date dateCreated\r\n    Date lastUpdated\r\n}\r\n```\r\n\r\n## License\r\nProject is licensed under Apache License 2.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}